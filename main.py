print("Введите количество переменных(максимум 64)")
a = input()
b = [] #Количество значений функции
k = 0 #Вспомогательная переменная
x = [] #Двумерный массив с табилцей истинности
m = 0 #Вспомогательная переменная
p = 0 #Вспомогательная переменная
tr = [] #Двумерный массив "Треугольник"
zh = [] #Массив для расчёта полинома Жегалкина 

if not a.isdigit(): #Проверка на ввод цифр
    print("Ваш ввод должен содержать цифры!")
    quit()

l = 2**int(a)#Количество значений функции равно двум в степени, равной количеству переменных

a = int(a)

for r in range(l):
    zh.append(0) # создаем пустую строку
    
print("Введите значения булевой функции в строчку\nПример для 3 переменных:0010101")
b = input()

pr = list(b) #Разделяем строку по каждой цифре, чтобы проверить правильность ввода 

if len(b) != l:
    print("Вы должны ввести", l, "цифр!")
    k=input("\n\npress close to exit") 
    quit()

if not b.isdigit(): #Проверка на ввод цифр
    print("Ваш ввод должен содержать цифры!")
    k=input("\n\npress close to exit") 
    quit()
    
for i in range(l):
    if ((int(pr[i]) != 1) and (int(pr[i]) != 0)):
        print("Вы можете ввести только 0 и 1!")
        k=input("\n\npress close to exit") 
        quit()

for r in range(l):
    x.append([]) # создаем пустую строку
    for c in range(a):
        x[r].append(0) # добавляем очередной элемент в строку

print()

k = -1
for r in range(l):
    tr.append([]) # создаем пустую строку
    k += 1
    for c in range(l - k): # Мы отнимаем от количества значений функции k так как треугольник сужается к низу
        tr[r].append(0) # добавляем очередной элемент в строку

k = 0
for i in range(a):
    for j in range(l):
        x[j][a - i - 1] = ((k // (2**i)) % 2) #Заполняем двумерный массив стандартной таблицей истинности, значения которой вычисляются по данной формуле
        k += 1

k = 0
for row in x:
    for elem in row:
        k += 1
        if (k % a == 0):
            print(elem, b[m], end = ' ') #Выводим элементы таблицы истинности, и если это конец строки, то выводим и значение функции при данном наборе
        else:
            print(elem, end=' ')
    print()
    m += 1
    
for i in range(l):
    tr[0][i] = int(b[i]) #Подготавливаем будущий треугольник, приравнивая значения функции к первой строке треугольника
    
print("\n\n")
for i in range(l - 1):
    for j in range(l - i - 1):
        tr[i + 1][j] = (tr[i][j] + tr[i][j+1])%2 #Складываем 2 верхних элемента по модулю 2, чтобы получить элемент следующей строки треугольника

k = 0    
for row in tr:
    for elem in row:
        print(elem, end = ' ')
    print()
    k += 1
    print(' ' * k, end='', flush=True)  #Количество пробелов зависит от строки треугольника, возрастает по мере приближения к вершине треугольника
    
    
for i in range(l): 
    zh[i] = tr[i][0] #Приравниваем левую сторону треугольника к вспомогательному масссиву, для поиска полинома Жегалкина
    
print()

m = 0
k = 0
for row in x:
    for elem in row:
        k += 1
        if (k % a == 0):
            print(elem, zh[m], end = ' ') #Выводим элементы таблицы истинности, и если это конец строки, то выводим и значение функции при данном наборе
        else:
            print(elem, end=' ')
    print()
    m += 1

print()

k = 0
for i in range(l):
    if (zh[i] == 1): #Узнаём сколько единичек получилось в левой стороне, это нужно для того, чтобы знать, когда кончается полином
        k += 1

print("P(F) = ", end = '')
for i in range(l):
    for j in range(a):
        if (zh[i] == 1):
            if (x[i][j] == 1):
                print("X", j + 1, sep="", end = '')
    if (zh[i] == 1):
        p += 1
    if (p != k): #Если это последнее "слагаемое" в полиноме, то нам не нужно ставить после него знак XOR, поэтому мы и считаем количество единиц сверху
        if (zh[i] == 1):
            print(" XOR ", end = '')

k=input("\n\npress close to exit") 
