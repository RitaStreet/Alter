mode = 1

while (mode == 1):
    print("Введите количество переменных(максимум 6)")
    kol = input() # количество переменных
    znach = [] #Значения функции
    k = 0 #Вспомогательная переменная
    tabl = [] #Двумерный массив с табилцей истинности
    m = 0 #Вспомогательная переменная для подсчёта количества итераций в цикле создания 
      #таблицы истинности, а также для подсчёта количества слагаемых в полиноме и количества нулей в значениях функции
    tr = [] #Двумерный массив "Треугольник"
    zh = [] #Массив для расчёта полинома Жегалкина 

    while(kol.isdigit() == False): #Проверка на ввод цифр
        print("Ваш ввод должен содержать цифры!")
        kol = input()
    
    while((int(kol) >6) or (int(kol) < 1)):
        print("Число должно быть меньше 6 и больше 0!\nПопробуйте ещё раз!")
        kol = input()

    l = 2**int(kol)#Количество значений функции равно двум в степени, равной количеству переменных

    kol = int(kol)

    zh = [0] * l # заполняем строку нулями
    
    print("Введите значения булевой функции в строчку\nПример для 3 переменных:0010101")
    znach = input()

    while(znach.isdigit() == False): #Проверка на ввод цифр
        print("Ваш ввод должен содержать цифры!\nПопробуйте ещё раз!")
        znach = input()

    while(len(znach) != l):
        print("Вы должны ввести", l, "цифр!\nПопробуйте ещё раз!")
        znach = input()
  
    pr = list(znach) #Разделяем строку по каждой цифре, чтобы проверить правильность ввода
    for i in range(l):
        if (int(pr[i]) == 0):
            m += 1
            
    if (m != l):
        if (m != 0):
            for i in range(l):
                if ((int(pr[i]) != 1) and (int(pr[i]) != 0)):
                    print("Вы можете ввести только 0 и 1!\nПопробуйте ещё раз!")
                    i = 0
                    znach = input()
                    pr = list(znach)

            for r in range(l):
                tabl.append([]) # создаем пустую строку
                tabl[r] = [0]*kol # заполняем строку нулями

            print()

            k = -1
            for r in range(l):
                tr.append([]) # создаем пустую строку
                k += 1
                tr[r] = [0] * (l - k) # заполняем строку нулями

            k = 0
            for i in range(kol):
                for j in range(l):
                    tabl[j][kol - i - 1] = ((k // (2**i)) % 2) #Заполняем двумерный массив стандартной таблицей истинности, значения которой вычисляются по данной формуле
                    k += 1

            k = 0
            m = 0
            for row in tabl:
                for elem in row:
                    k += 1
                    if (k % kol == 0):
                        print(elem, znach[m], end = ' ') #Выводим элементы таблицы истинности, и если это конец строки, то выводим и значение функции при данном наборе
                    else:
                        print(elem, end=' ')
                print()
                m += 1
    
            for i in range(l):
                tr[0][i] = int(znach[i]) #Подготавливаем будущий треугольник, приравнивая значения функции к первой строке треугольника
    
            print("\n\n")
            for i in range(l - 1):
                for j in range(l - i - 1):
                    tr[i + 1][j] = (tr[i][j] + tr[i][j+1])%2 #Складываем 2 верхних элемента по модулю 2, чтобы получить элемент следующей строки треугольника

            k = 0    
            for row in tr:
                for elem in row:
                    print(elem, end = ' ')
                print()
                k += 1
                print(' ' * k, end='', flush=True)  #Количество пробелов зависит от строки треугольника, возрастает по мере приближения к вершине треугольника
    
    
            for i in range(l): 
                zh[i] = tr[i][0] #Приравниваем левую сторону треугольника к вспомогательному масссиву, для поиска полинома Жегалкина
    
            print()

            m = 0
            k = 0
            for row in tabl:
                for elem in row:
                    k += 1
                    if (k % kol == 0):
                        print(elem, zh[m], end = ' ') #Выводим элементы таблицы истинности, и если это конец строки, то выводим и значение функции при данном наборе
                    else:
                        print(elem, end=' ')
                print()
                m += 1

            print()

            k = 0
            for i in range(l):
                if (zh[i] == 1): #Узнаём сколько единичек получилось в левой стороне, это нужно для того, чтобы знать, когда кончается полином
                    k += 1

            m = 0
            print("P(F) = ", end = '')
            if (int(znach[0]) == 1):
                print("1", sep = "", end = '')
            for i in range(l):
                for j in range(kol):
                    if (zh[i] == 1):
                        if (tabl[i][j] == 1):
                            print("X", j + 1, sep = "", end = '')
                if (zh[i] == 1):
                    m += 1
                if (m != k): #Если это последнее "слагаемое" в полиноме, то нам не нужно ставить после него знак XOR, поэтому мы и считаем количество единиц сверху
                    if (zh[i] == 1):
                        print(" XOR ", end = '')
        else:
            print("\nФункция является константой 1, поэтому полином Жегалкина равен единице")
    else:
        print("\nФункция является константой 0, поэтому полином Жегалкина равен нулю")
    
    print("\nРассчитать ещё один полином?\n1 - да\n2 - нет") 
    k = input()
    
    while(len(k) != 1):
        print("Вы должны ввести только одну цифру!\nПопробуйте ещё раз!\n1 - да\n2 - нет")
        k = input()
    
    while(k.isdigit() == False): #Проверка на ввод цифр
        print("Ваш ввод должен содержать только цифру!\nПопробуйте ещё раз!\n1 - да\n2 - нет")
        k = input()
        
    while((int(k) > 2) or (int(k) < 1)):
        print("Ваш ввод должен содержать либо 1 либо 2!\nПопробуйте ещё раз!\n1 - да\n2 - нет")
        k = input()
        
    if (int(k) == 2):
        m = input("\n\nНажмите Enter для выхода")
        quit()
