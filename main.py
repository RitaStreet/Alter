
print("Введите количество переменных(максимум 6)")
kol = input() # количество переменных
znach = [] #Значения функции
k = 0 #Вспомогательная переменная
tabl = [] #Двумерный массив с табилцей истинности
m = 0 #Вспомогательная переменная для подсчёта количества итераций в цикле создания 
      #таблицы истинности, а также для подсчёта количества слагаемых в полиноме
tr = [] #Двумерный массив "Треугольник"
zh = [] #Массив для расчёта полинома Жегалкина 

while(kol.isdigit() == False): #Проверка на ввод цифр
    print("Ваш ввод должен содержать цифры!")
    kol = input()

l = 2**int(kol)#Количество значений функции равно двум в степени, равной количеству переменных

kol = int(kol)

zh = [0] * l # заполняем строку нулями
    
print("Введите значения булевой функции в строчку\nПример для 3 переменных:0010101")
znach = input()

while(znach.isdigit() == False): #Проверка на ввод цифр
    print("Ваш ввод должен содержать цифры!\nПопробуйте ещё раз!")
    znach = input()

while(len(znach) != l):
    print("Вы должны ввести", l, "цифр!\nПопробуйте ещё раз!")
    znach = input()
  
pr = list(znach) #Разделяем строку по каждой цифре, чтобы проверить правильность ввода   
    
for i in range(l):
    if ((int(pr[i]) != 1) and (int(pr[i]) != 0)):
        print("Вы можете ввести только 0 и 1!\nПопробуйте ещё раз!")
        i = 0
        znach = input()
        pr = list(znach)

for r in range(l):
    tabl.append([]) # создаем пустую строку
    tabl[r] = [0]*kol # заполняем строку нулями

print()

k = -1
for r in range(l):
    tr.append([]) # создаем пустую строку
    k += 1
    tr[r] = [0] * (l - k) # заполняем строку нулями

k = 0
for i in range(kol):
    for j in range(l):
        tabl[j][kol - i - 1] = ((k // (2**i)) % 2) #Заполняем двумерный массив стандартной таблицей истинности, значения которой вычисляются по данной формуле
        k += 1

k = 0
for row in tabl:
    for elem in row:
        k += 1
        if (k % kol == 0):
            print(elem, znach[m], end = ' ') #Выводим элементы таблицы истинности, и если это конец строки, то выводим и значение функции при данном наборе
        else:
            print(elem, end=' ')
    print()
    m += 1
    
for i in range(l):
    tr[0][i] = int(znach[i]) #Подготавливаем будущий треугольник, приравнивая значения функции к первой строке треугольника
    
print("\n\n")
for i in range(l - 1):
    for j in range(l - i - 1):
        tr[i + 1][j] = (tr[i][j] + tr[i][j+1])%2 #Складываем 2 верхних элемента по модулю 2, чтобы получить элемент следующей строки треугольника

k = 0    
for row in tr:
    for elem in row:
        print(elem, end = ' ')
    print()
    k += 1
    print(' ' * k, end='', flush=True)  #Количество пробелов зависит от строки треугольника, возрастает по мере приближения к вершине треугольника
    
    
for i in range(l): 
    zh[i] = tr[i][0] #Приравниваем левую сторону треугольника к вспомогательному масссиву, для поиска полинома Жегалкина
    
print()

m = 0
k = 0
for row in tabl:
    for elem in row:
        k += 1
        if (k % kol == 0):
            print(elem, zh[m], end = ' ') #Выводим элементы таблицы истинности, и если это конец строки, то выводим и значение функции при данном наборе
        else:
            print(elem, end=' ')
    print()
    m += 1

print()

k = 0
for i in range(l):
    if (zh[i] == 1): #Узнаём сколько единичек получилось в левой стороне, это нужно для того, чтобы знать, когда кончается полином
        k += 1

m = 0
print("P(F) = ", end = '')
for i in range(l):
    for j in range(kol):
        if (zh[i] == 1):
            if (tabl[i][j] == 1):
                print("X", j + 1, sep="", end = '')
    if (zh[i] == 1):
        m += 1
    if (m != k): #Если это последнее "слагаемое" в полиноме, то нам не нужно ставить после него знак XOR, поэтому мы и считаем количество единиц сверху
        if (zh[i] == 1):
            print(" XOR ", end = '')

k=input("\n\npress close to exit") 
